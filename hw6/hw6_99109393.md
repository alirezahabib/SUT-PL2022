# EOPL Pset 6
> Alireza Habibzadeh `99109393`

## 1

### الف
به نظر من در این روش دو فایده وجود دارد.

یکی این که کار برنامه‌نویس ساده‌تر می‌شود و فکر کردنش سطح بالاتر و دورتر از مفاهیم ماشین پس زبان سطح بالاتر می‌شود و کد کوتاه‌تر.
[به قولی](https://www.youtube.com/watch?v=X0-SXS6zdEQ)
وقتی اشیا روی میز را نام می‌برید به type ‌آن‌ها فکر نمی‌کنید. به این که این یک لیوان از جنس پلاستیک از رده‌ی لیوان‌های استوانه‌ای و... است فکر نمی‌کنید. تنها می‌گویید این یک لیوان است و اگر لازم شد اطلاعات بیشتری می‌دهید یا خود فرد آن‌ها را استنتاج می‌کند.

>*...I mean, types are there to make the compiler writer's jobs easier. Types are not, I mean.. Heck, do you have an ontology of types for just the objects in this table? No. So types are there because compiler writers are human and they're limited in  what they can do.*
--Peter Wang (Python)


فایده‌ی دوم این که به نظر من type-checking تغییرات کد را در آینده دشوارتر می‌کند. روش type-inference هرچند dynamic با تعریف زبان‌های dynamic نیست، اما به یک زبان dynamic نزدیک‌تر است چرا که تنها با تغییر کوچک در روندی که type نهایی توسط مفسر infer شده (مثلا عوض کردن type خروجی یک تابع) می‌توان کارکرد یک برنامه را کلی‌تر کرد یا از کاربردی به کاربرد دیگر کوچ داد. (مثلا فرایندی از جنس
$int \to int$
که شباهت‌هایی به فرایند دیگری از جنس
$int \to bool$
دارد در صورتی که به روش type-checking پیاده شده باشد نیاز به تغییر بسیاری از تایپ‌های خروجی دارد اما در روش type-inference چند تغییر جزیی کار را انجام می‌دهد.

### ب
با این که هر دو زبان
strongly-typed 
محسوب می‌شوند
دلیل این حرف این است که واقعا در
Java
هرچند به قیمت 
performance 
پایین‌تر
type-checking بیشتری
وجود دارد.

```Java
// Java is more strongly typed than C

public class MyClass {
    public static void main(String args[]) {
      float value  = 6.98;  // compile-time error 
      double value2 = 6.98;  // OK
      float value3  = 6.98f; // also OK
    }
}
```

```
/MyClass.java:3: error: incompatible types: possible lossy conversion from double to float
      float value = 6.98;  // compile-time error
                    ^
1 error
```

در کد بالا عدد 6.98 ابتدا به صورت یک 
double
تولید شده و سپس 
کامپایلر سعی دارد آن را به 
یک متغییر از جنس
assign
float
کند.
از آنجایی که این تبدیل ممکن است بی‌نقص نباشد و مقداری داده دور ریخته شود
کامپایلر جاوا مگر این که برنامه‌نویس صراحتا تبدیل تایپ را بیان کند اجازه‌ی این کار را نمی‌دهد.

>Notable examples of weakly typed languages are C and C++ and to a lesser extent Pascal. For example parameter type checking in function calls was not present in the original version of C. This was largely rectified in ANSI C (and C++) but calls to functions which take a variable number of parameters (such as the standard library functions for formatted I/O (scanf and printf) are not fully type checked. Also in C and C++ array parameters are not fully type checked. Java is more strongly typed than C or C++, but somewhat less strongly typed than Ada in respect of objects. For example in Java a variable of some class type T can hold references not only to objects of type T, but also references to objects of any type derived from T. The type of a value stored in such a variable cannot be determined fully until run-time. 

>References are strongly typed. Another difference is that the type of a reference is much more strictly controlled in Java than the type of a pointer is in C. In C you can have an int* and cast it to a char* and just re-interpret the memory at that location. That re-interpretation doesn't work in Java: you can only interpret the object at the other end of the reference as something that it already is (i.e. you can cast a Object reference to String reference only if the object pointed to is actually a String).

به طور کلی زمانی می‌توان گفت یک زبان
strongly-typed
است که
در آن زبان یک سخت‌گیری حداقلی در چک شدن، اظهار 
توسط برنامه‌نویس
و تبدیل
typeها
وجود دارد.
به عبارتی هر لحظه که برنامه‌نویس عبارتی را می‌نویسد باید حواسش به تایپ تک‌تک عناصر و تبدیل شدن آن‌ها باشد و نمی‌تواند کارها را به مفسر زبان واگذار کند.

البته اینجا مقایسه بین دو زبانی هست که هر دو 
strongly-typed 
محسوب می‌شوند.

>Java, C#, Ada and Pascal are sometimes said to be more strongly typed than C, a claim that is probably based on the fact that C supports more kinds of implicit conversions, and C also allows pointer values to be explicitly cast while Java and Pascal do not. [[Wikipedia](https://en.wikipedia.org/wiki/Strong_and_weak_typing#Variation_across_programming_languages)]

## 2

| Expression                                 | Type Variable |
| ------------------------------------------ | ------------- |
| `p`                                        | $t_p$         |
| `let p = zero?(1) in if p then 88 else 99` | $t_0$         |
| `zero?(1)`                                 | $t_1$         |
| `if p then 88 else 99`                     | $t_2$         |


| Expression                                 | Equations     |
| ------------------------------------------ | ------------- |
| `let p = zero?(1) in if p then 88 else 99` | $t_p = t_1$   |
|                                            | $t_0 = t_2$   |
| `zero?(1)`                                 | $t_1 = bool$  |
|                                            | $int = int$   |
| `if p then 88 else 99`                     | $t_p = bool$  |
|                                            | $t_2 = int$   |
|                                            | $t_2 = int$   |



