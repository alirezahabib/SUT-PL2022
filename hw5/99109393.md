# EOPL Pset 5
> Alireza Habibzadeh `99109393`

## 1
خروجی این برنامه 0 است چرا که با هر بار اجرای این تابع مقدار ‍`counter` برابر با 0 می‌شود و سپس یکی زیاد می‌شود. سپس مقدار 1 خروجی داده می‌شود.
در هر دو اجرای تابع همین اتفاق می‌افتد پس خروجی هر دو 1 است و تفاضلشان 0.

برای حل ایراد کد (اگر قرار است تابع به عنوان شمارنده استفاده شود) می‌توان آدرسی که در `counter` نگه داشته می‌شود (که عدد شمارنده ما در آن ذخیره می‌شود) را
تنها یکبار و قبل از تعریف تابع تعیین کرد.


```racket
let counter = newref(0)
  in let g = proc (dummy)
  
    in begin
      setref(counter, -(deref(counter), -1));
      deref(counter)
    end
  in let a = (g 20)
    in let b = (g 20)
      in -(a, b)
```


## 2

## 3

## 4

## 5
