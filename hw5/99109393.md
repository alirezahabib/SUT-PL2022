# EOPL Pset 5
> Alireza Habibzadeh `99109393`

## 1
خروجی این برنامه 0 است چرا که با هر بار اجرای این تابع مقدار ‍`counter` برابر با 0 می‌شود و سپس یکی زیاد می‌شود. سپس مقدار 1 خروجی داده می‌شود.
در هر دو اجرای تابع همین اتفاق می‌افتد پس خروجی هر دو 1 است و تفاضلشان 0.

برای حل ایراد کد (اگر قرار است تابع به عنوان شمارنده استفاده شود) می‌توان آدرسی که در `counter` نگه داشته می‌شود (که عدد شمارنده ما در آن ذخیره می‌شود) را
تنها یکبار و قبل از تعریف تابع تعیین کرد.

```racket
let counter = newref(0)
  in let g = proc (dummy)
    in begin
      setref(counter, -(deref(counter), -1));
      deref(counter)
    end
  in let a = (g 20)
    in let b = (g 20)
      in -(a, b)
```


**پس از این اصلاح** با هر بار اجرای تابع مقداری که `counter` در حافظه به آن اشاره می‌کند یکی زیاد می‌شود پس حاصل برابر با
$$ a - b = 1 - 2 = -1 $$
است.


## 2

برای این کار چند روش به ذهن من می‌رسد. یکی از این‌ها وقتی قابل اجرا است که زبان ما امکان کار با referenceها چه به صورت implicit و چه به صورت explicit داشته باشد. در این صورت هر ورودی تابع که به صورت یک reference باشد عملا خروجی هم هست! چرا که درست است که نمی‌توانیم خود مقدار متغییر در جایی که تابع ما را call کرده تغییر دهیم (عملا خود آدرسی که به ما پاس داده شده) اما می‌توانیم مقداری که در آن‌جای حافظه ذخیره شده را تغییر دهیم. مثال زیر به زبان IMPLICIT-REFS نوشته شده است:

```racket
let rotate = proc (a, b) in 
  let temp = -(a, 0) in ; to make temp a deep copy of a
    begin
    set a = -(0, b);
    set b = temp;
    34
  end
  in let x = 20
    in let y = 30
      in (rotate 20 30)
```

$$ (x, y) \to (-y, x) $$

خروجی برگشتی تابع یک مقدار dummy برابر با 34 است. اما خروجی واقعی تابع تغییر کردن متغییرهای `x` و ‍`y` پاس داده شده به آن هستند.

یک روش دیگر برای خروجی دادن چند متغییر خروجی دادن یک لیست است. در زبان `let-rec` که به کلی از referenceها هم پشتیبانی نمی‌کند می‌توان خروجی‌های تابع را در یک لیست ریخت و آن لیست را خروجی داد و از مقادیر جداگانه استفاده کرد. البته باید دقت کنیم برای کامل بودن این روش بهتر است بتوان اعضای لیست از جنس‌های مختلف باشند. (برخلاف بعضی زبان‌ها و بعضی ساختارهایشان که همه‌ی اعضای لیست باید از یک جنس باشند)

روش دیگر استفاده از structها و ساختارهای داده است که هم در زبان racket و هم در بسیاری از زبان‌ها پشتیبانی می‌شود. می‌توانیم برای هر تابعی که نیاز به خروجی‌های متعدد دارد یک struct بسازیم که آن را به عنوان خروجی تحویل دهد.

در انتها روشی که در کلاس هم اشاره شد استفاده از mutable-pairها است. این‌ها یک ساختار جدید هستند که اجازه می‌دهند دو مقدار به صورت mutable در یک ساختار واحد کنار هم قرار گیرند.
البته این روش‌ها شبیه هم هستند و به نوعی این روش حالت خاص روش قبلی است.

## 3

ابتدا به این نکته توجه می‌کنیم که در یک زبان pure functional مقدار هر متغییر همواره یک چیز است و side effect حافظه‌ای نداریم. پس عملا اثبات شد که برای این زبان‌ها هر دو روش call-by-need و call-by-name نمی‌تواند فرقی داشته باشد چرا در هر دو روش مقدار متغییر چه یکبار ارزیابی شود و چه چند بار همواره یکسان است. 

پس برای ایجاد تفاوت باید یک side effect حافظه با ارزیابی شدن متغییر باشیم. از شمارنده‌ی سوال 1 تمرین استفاده می‌کنیم.

```racket
let counter = newref(0)
  in let g = proc (dummy)
    in begin
      setref(counter, -(deref(counter), -1));
      deref(counter)
    end
  in let a = (g 20)
      in -(a, a)
```

در زبانی که lazy و call-by-need باشد مقدار `a` در expression آخر تنها یکبار ارزیابی شده و حاصل تفریق برابر با 0 است اما در زبان‌های lazy و call-by-name
مقدار `a` در expression آخر دو بار ارزیابی می‌شود که در بار اول برابر با 1 و بار دوم برابر با 2 است پس حاصل برابر با 1- و متفاوت با  
زبان دیگر شد.

## 4

## 5
